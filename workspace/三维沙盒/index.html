<style>body{margin: 0;}</style>
<script src="https://img1.ccgxk.com/wjs/w.js"></script>
<script src="https://img1.ccgxk.com/jscdn/cannon.min.js"></script>
<canvas id=c width=320 height=300></canvas>
<script>

/* -----------------------------[ 变量区 ]----------------------------------------- */
// 这些是主角的初始位置
var X = 7.2, Z = 30.8, Y = 14.3,
    RX = -104.2, RY = -15.7, RZ = 0;

/* -----------------------------[ w.js 初始化 ]----------------------------------------- */
c.width = window.innerWidth - 100
c.height = window.innerHeight -100
W.reset(c);
W.ambient(0.7);
W.light({x:.5,y:-.3,z:-.5});
W.clearColor("8Af");

/* -----------------------------[ 绘制原点坐标轴 ]----------------------------------------- */
W.cube({x:5,w:10,h:.5,d:.5,b:"f44"});    
W.cube({y:5,h:10,w:.5,d:.5,b:"4f4"});
W.cube({z:5,d:10,w:.5,h:.5,b:"44f"});
W.pyramid({size:1,x:10,rz:-90,b:"f44"});
W.pyramid({size:1,y:10,b:"4f4"});
W.pyramid({size:1,z:10,rx:90,b:"44f"});

/* -----------------------------[ 物理引擎初始化 ]----------------------------------------- */
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0);  // 重力加速度，模拟地球重力9.82m/s²
world.broadphase = new CANNON.NaiveBroadphase();  // 基础碰撞检测算法
world.solver.iterations = 10;  // 设置物理迭代次数
const cannonDefaultCantactMaterial = new CANNON.ContactMaterial(  // 创建两个默认材质的关联材质
  new CANNON.Material(),
  new CANNON.Material(),
  {
    friction: 0.5, // 摩擦力
    restitution: 0.7, // 弹性系数
  }
)
world.addContactMaterial(cannonDefaultCantactMaterial)

/* -----------------------------[ 创建地面物理体 ]----------------------------------------- */
const groundBody = new CANNON.Body({ // 添加地面
                            mass: 0, // 质量为0
                            position: new CANNON.Vec3(0, 0, 0),  // 坐标原点
                            shape: new CANNON.Plane(),  // 一个无限延伸的平面
                            material: cannonDefaultCantactMaterial,
                  });
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);  // 旋转平面90度
world.addBody(groundBody);

/* -----------------------------[ w.js 创建地面模型 ]----------------------------------------- */
W.group({n: "ground", x: 0, y: 0.5, z: 0});
W.plane({
  g: "ground",
  n: "ground_plane",
  size: 20,
  b: "#8bc34a",
  s: 0.5,
  rx: -90
});

/* -----------------------------[ 创建球体物理体 ]----------------------------------------- */
const sphereBody = new CANNON.Body({ 
                              mass: 5,
                              shape: new CANNON.Sphere(1),  // 半径为 1 的球体
                              position: new CANNON.Vec3(0, 30, 0),  // 位置
                              material: cannonDefaultCantactMaterial,
                    });
world.addBody(sphereBody);

/* -----------------------------[ w.js 创建球体模型 ]----------------------------------------- */
W.group({n: "ball", x: 0, y: 0, z: 0});
W.sphere({
  g: "ball",
  n: "ball_sphere",
  size: 1,
  b: "#2196f3",
  s: 0.8
});


/* -----------------------------[ 绘制主角和摄像机 ]----------------------------------------- */
W.sphere({n:"M",size:1, x:X, y:Y, z:Z, rx:RX, ry:RY, rz:RZ, b:"ccc",s:1});
W.sphere({g:"M", n:"head",size:0.6,y:0, z:0.6, rx:-90,ry:0, b:"ccc",s:1});   // 头绑定身体 M，注意，坐标以 M 为基准
W.camera({g:"M",z:.5,y:-2.5,rx:90});  // 摄像机，此时它的 g 属性为主角 sphere 的 n 属性，摄像机与主角绑定

/* -----------------------------[ 按键事件 ]----------------------------------------- */

keys = {  // 操作值
  viewForward:0,
  viewBackward:0,
  turnRight:0,
  turnLeft:0,
  turnUp:0,  // 视角向上转动
  turnDown:0,
  viewUp:0,
  viewDown:0,
  viewLeft:0,
  viewRight:0,
};

  
const keyMap = {  // 键盘按键与操作值的对应关系
  'w': 'viewForward',
  's': 'viewBackward', 
  'a': 'viewLeft',
  'd': 'viewRight',
  'r': 'viewUp',
  'v': 'viewDown',
  'o': 'turnUp',
  'p': 'turnDown',
  'k': 'viewLeft',
  'l': 'viewRight',
  'arrowup': 'viewForward',
  'arrowdown': 'viewBackward',
  'arrowleft': 'turnLeft',
  'arrowright': 'turnRight',
};
const handleKey = (e, value) => {
  if(keyMap[e.key.toLowerCase()]) {
    keys[keyMap[e.key.toLowerCase()]] = value;
  }
  if(e.keyCode === 32) {
    keys['viewUp'] = value; 
  }
};
onkeydown = e => handleKey(e, 1);
onkeyup = e => handleKey(e, 0); 
// onkeydown = e => {console.log(e.key)};  // 调试使用

/* -----------------------------[ 视角变化 ]----------------------------------------- */
function viewChangeAction(){
  if(keys.viewForward || keys.viewBackward) {  // 前后平移
    W.move({n:"M", z: Z += (-keys.viewForward + keys.viewBackward) * Math.cos(RY*Math.PI/180) / 10,
                    x: X += (-keys.viewForward + keys.viewBackward) * Math.sin(RY*Math.PI/180) / 10
    });
  }
  if(keys.viewLeft || keys.viewRight) {  // 左右平移
    W.move({n:"M", z: Z += (-keys.viewLeft + keys.viewRight) * Math.cos((RY + 90)*Math.PI/180) / 10,
                    x: X += (-keys.viewLeft + keys.viewRight) * Math.sin((RY + 90)*Math.PI/180) / 10
    });
  }
  if(keys.viewUp || keys.viewDown) {  // 上下平移
    var _number = (keys.viewUp - keys.viewDown) / 7;
    Y += _number;
    W.move({n:"M", y: Y});
  }
  if(keys.turnRight || keys.turnLeft) {  // 左右扭动
    var offset = (-keys.turnRight + keys.turnLeft);
    if(Math.abs(offset) > 0.1){
        RY += offset;
        W.move({n:"M", ry: RY});
    }
  }
  if(keys.turnUp || keys.turnDown) {  // 上下扭动
    var offset = (-keys.turnUp + keys.turnDown);
    if(Math.abs(offset) > 0.5){
      if ((offset > 0 && RX < 0) || (offset < 0 && RX > -180)) {
        RX += offset;
      }
    }
    W.move({ n: "M", rx: RX });  
  }
}

/* -----------------------------[ 函数，计算移动变化 ]----------------------------------------- */
function calMovePara(X, Y, Z, RX, RY, RZ){
  if(keys.viewForward || keys.viewBackward) {  // 前后平移
    Z += (-keys.viewForward + keys.viewBackward) * Math.cos(RY*Math.PI/180) / 10;
    X += (-keys.viewForward + keys.viewBackward) * Math.sin(RY*Math.PI/180) / 10;
  }
  if(keys.viewLeft || keys.viewRight) {  // 左右平移
    W.move({n:"M", z: Z += (-keys.viewLeft + keys.viewRight) * Math.cos((RY + 90)*Math.PI/180) / 10,
                    x: X += (-keys.viewLeft + keys.viewRight) * Math.sin((RY + 90)*Math.PI/180) / 10
    });
  }
  if(keys.viewUp || keys.viewDown) {  // 上下平移
    var _number = (keys.viewUp - keys.viewDown) / 7;
    Y += _number;
    W.move({n:"M", y: Y});
  }
  if(keys.turnRight || keys.turnLeft) {  // 左右扭动
    var offset = (-keys.turnRight + keys.turnLeft);
    if(Math.abs(offset) > 0.1){
        RY += offset;
        W.move({n:"M", ry: RY});
    }
  }
  if(keys.turnUp || keys.turnDown) {  // 上下扭动
    var offset = (-keys.turnUp + keys.turnDown);
    if(Math.abs(offset) > 0.5){
      if ((offset > 0 && RX < 0) || (offset < 0 && RX > -180)) {
        RX += offset;
      }
    }
    W.move({ n: "M", rx: RX });  
  }
}

/* -----------------------------[ Pointer Lock 和鼠标移动事件 ]----------------------------------------- */
let isMouseMove = false;
c.addEventListener('mousemove', (e) => {
  if(isMouseMove){
    keys.turnRight = e.movementX * 0.1;
    keys.turnUp = e.movementY * 0.1;
  }
});
c.addEventListener('click', () => {
  c.requestPointerLock = c.requestPointerLock || c.mozRequestPointerLock || c.webkitRequestPointerLock;
  c.requestPointerLock();
  isMouseMove = true;
});
document.addEventListener('pointerlockchange', lockChangeAlert, false);
document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);
function lockChangeAlert() {
  if (document.pointerLockElement === c||document.mozPointerLockElement === c||document.webkitPointerLockElement === c) {
    isMouseMove = true;
  } else {
    isMouseMove = false;
  }
}

/* -----------------------------[ 物理动作 ]----------------------------------------- */
function cannonAni(){
  const timeStep = 1/60;  // 时间步长
  world.step(timeStep);  // 更新物理世界
  W.move({  // 更新球体位置和旋转
    n: "ball",
    x: sphereBody.position.x,
    y: sphereBody.position.y,
    z: sphereBody.position.z,
    rx: sphereBody.quaternion.x,
    ry: sphereBody.quaternion.y,
    rz: sphereBody.quaternion.z
  });
}

/* -----------------------------[ 帧运行 ]----------------------------------------- */
function animate() {
  requestAnimationFrame(animate);
  viewChangeAction();  // 改变视角
  cannonAni();  // 物理世界
}
animate();

</script>