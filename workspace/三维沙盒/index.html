<style>body{margin: 0;}</style>
<script src="./js/w.js"></script>
<script src="./js/cannon.js"></script>
<img src='./img/texture.jpeg' id=marble hidden>
<script src="https://xem.github.io/W/demos/mario.js"></script>
<script src="https://xem.github.io/W/demos/mariotexture.js"></script>
<canvas id=c width=320 height=300></canvas>
<div id="fpsInfo"></div>
<div id="shiftInfo"></div>
<div id="posInfo"></div>
<script>
// import * as CANNON from './js/cannon-es.js';

// 一些数学函数
var wMath = {
    quaternionToEuler: function(q){  // 四元数转化为欧拉数
        const { x, y,  z,  w } = q;
        const roll = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y)); // Roll (X轴)
        const sinPitch = 2 * (w * y - z * x);
        const pitch = Math.asin(Math.max(-1, Math.min(1, sinPitch))); // Pitch (Y轴)
        const yaw = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z)); // Yaw (Z轴)
        const toDeg = angle => angle * (180 / Math.PI); // 转为度数
        return { rX: toDeg(roll), rY: toDeg(pitch), rZ: toDeg(yaw)};
    },

    eulerToQuaternion: function(roll, pitch, yaw){  // 欧拉数转化为四元数（目前用不到）
        const rollRad = roll * (Math.PI / 180);
        const pitchRad = pitch * (Math.PI / 180);
        const yawRad = yaw * (Math.PI / 180);
        const cr = Math.cos(rollRad * 0.5);
        const sr = Math.sin(rollRad * 0.5);
        const cp = Math.cos(pitchRad * 0.5);
        const sp = Math.sin(pitchRad * 0.5);
    },
}

// w.js 初始化
c.width = window.innerWidth - 100
c.height = window.innerHeight - 100
W.reset(c);
W.ambient(0.7);
W.light({ x: 0.5, y: -0.3, z: -0.5});
W.clearColor("8Af");

// 绘制原点坐标轴
W.group({n:'posZero',x:0,y:1,z:0});
W.cube({g:'posZero',x:5,w:10,h:.5,d:.5,b:"f44"});
W.cube({g:'posZero',y:5,h:10,w:.5,d:.5,b:"4f4"});
W.cube({g:'posZero',z:5,d:10,w:.5,h:.5,b:"44f"});
W.pyramid({g:'posZero',size:1,x:10,rz:-90,b:"f44"});
W.pyramid({g:'posZero',size:1,y:10,b:"4f4"});
W.pyramid({g:'posZero', n:'test0001' ,size:1,z:10,rx:90,b:"44f"});



// 项目对象
var ccgxk = {
    // 初始化物理世界
    initWorld : function(){
        W.camera({n:'camera'});  // 初始化相机
        this.world = new CANNON.World();
        this.world.gravity.set(0, -9.82, 0); // 地球重力9.82m/s²
        // this.world.broadphase = new CANNON.NaiveBroadphase(); // 碰撞检测（所有刚体件都进行碰撞）
        this.world.broadphase = new CANNON.SAPBroadphase(this.world) // SAP 分割
        // this.world.broadphase = new CANNON.GridBroadphase() // 网格分割
        // this.world.allowSleep = true; // 允许睡眠
        this.world.solver.iterations = 20; // 物理迭代
        this.world.addContactMaterial(this.cannonDefaultCantactMaterial);  // 默认材质关联
        this.eventListener();  // 事件监听
        this.animate(); // 动画
    },

    // ccgxk 的 cannon.js 物理世界
    world : null,

    // 默认材质关联材质
    cannonDefaultCantactMaterial : new CANNON.ContactMaterial( // 默认材质关联材质
        new CANNON.Material(),
        new CANNON.Material(), {
            friction: 0.1, // 摩擦力
            restitution: 0.1, // 弹性系数
    }),

    // 物理体列表
    bodylist : new Array(),

    // 添加 box 物理体
    addPhysicalBox : function({ 
                name = 'k'+(Math.random()*10**9|0),  // 如果没指认，则使用随机数生成 ID
                X = 5, Y = 5, Z = 5,
                mass = 0, width = 1, depth = 1, height = 1,
                texture = null, smooth = 0.8, background = '#888', mixValue = 0.71, rX = 0, rY = 0, rZ = 0 } = {}){
        
        const body = new CANNON.Body({
            mass : mass,
            shape: new CANNON.Box(new CANNON.Vec3(width, height, depth)),
            position: new CANNON.Vec3(X, Y, Z),
            material: ccgxk.cannonDefaultCantactMaterial,
        });
        this.world.addBody(body);
        W.cube({
            n: name,
            w: width * 2, d: depth * 2, h: height * 2,
            x: X, y:Y, z:Z, t: texture, s: smooth,
            rx: rX, ry: rY, rz: rZ, b: background, mix: mixValue
        });
        var result = { name, body, rX, rY, rZ };
        this.bodylist.push(result);
        return result;
    },

    // 按照列表将 物理体 逐个更新
    updataBodylist : function(){
        for (let i = 0; i < this.bodylist.length; i++) {
            let indexItem = this.bodylist[i];
            let pos = indexItem.body.position;
            let quat = indexItem.body.quaternion;
            let indexItemEuler = wMath.quaternionToEuler(quat);
            indexItem.rX = indexItemEuler.rX;
            indexItem.rY = indexItemEuler.rY;
            indexItem.rZ = indexItemEuler.rZ;
            W.move({
                n: this.bodylist[i].name,
                x: pos.x,
                y: pos.y,
                z: pos.z,
                rx: indexItem.rX,
                ry: indexItem.rY,
                rz: indexItem.rZ,
            });
        }
    },

    // 操作状态值
    keys : {
        viewForward: 0,
        viewBackward: 0,
        turnRight: 0,
        turnLeft: 0,
        turnUp: 0,
        turnDown: 0,
        viewUp: 0,
        viewDown: 0,
        viewLeft: 0,
        viewRight: 0,
        shiftKeyvalue: 0,
        jumping: 0,
    },

    // 键盘按键与操作状态值的对应
    keyMap : {
        'w': 'viewForward',
        's': 'viewBackward',
        'a': 'viewLeft',
        'd': 'viewRight',
        'q': 'turnLeft',
        'e': 'turnRight',
        'r': 'viewUp',
        'v': 'viewDown',
        'o': 'turnUp',
        'p': 'turnDown',
        'k': 'viewLeft',
        'l': 'viewRight',
        'arrowup': 'viewForward',
        'arrowdown': 'viewBackward',
        'arrowleft': 'turnLeft',
        'arrowright': 'turnRight',
    },

    isShiftPress : 0,

    // 事件监听
    eventListener : function(){
        var _this = this;
        var isMouseMove = false;
        document.addEventListener('keydown', function(e) {  // 按下键盘
            _this._handleKey(e, 1);
        });
        document.addEventListener('keyup', function(e) {  // 松开键盘
            _this._handleKey(e, 0);
        });
        document.addEventListener('mousemove', function(e) {  // 鼠标移动
            if (isMouseMove) {
                _this.keys.turnRight = e.movementX * 0.1;
                _this.keys.turnUp = e.movementY * 0.1;
            }
        });
        c.addEventListener('click', () => {  // 点击画布，开启虚拟鼠标
            c.requestPointerLock = c.requestPointerLock || c.mozRequestPointerLock || c.webkitRequestPointerLock;
            c.requestPointerLock();
            isMouseMove = true;
        });
        document.addEventListener('pointerlockchange', lockChangeAlert, false);
        document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
        document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);
        function lockChangeAlert() {  // 单击 ESC 键后
            if (document.pointerLockElement === c || document.mozPointerLockElement === c || document.webkitPointerLockElement === c) {
                isMouseMove = true;
            } else {
                isMouseMove = false;
            }
        }
    },

    // 键盘事件处理逻辑
    _handleKey : function(e, value) {
        var action = this.keyMap[e.key.toLowerCase()];
        if (action) { this.keys[action] = value; }
        if (e.keyCode === 32 && this.mainVPlayer !== null) {  // 空格键
            var limit = this.mainVPlayer.body.position.y <= 0;
            limit = true;
            if (this.keys.jumping === 0 && limit) {
                this.mainVPlayer.body.velocity.y = 10;
            }
            this.keys.jumping = value;
        }
        if (e.keyCode === 16) {  // shift键
            this.isShiftPress = value;
        }
    },

    // 主角移动和旋转
    mainVPlayerMove : function(mainVPlayerObj){
        if(mainVPlayerObj === null){return};
        var cam = this.mainCamera;
        cam.groupName = mainVPlayerObj.name;
    },

    forwardAcc : 0,



    // 计算物体的移动参数
    calMovePara : function(X, Y, Z, RX, RY, RZ){
        const keys = this.keys;
        if (keys.viewForward || keys.viewBackward) { // 前后平移
            var speed = (this.isShiftPress) ? Math.max(0.3,4-(this.forwardAcc+=0.01)) :4+0*(this.forwardAcc=0.01);  // 加速度
            shiftInfo.innerHTML = 'speed:' + Math.round((100 / speed));
            Z += (-keys.viewForward + keys.viewBackward) * Math.cos(RY * Math.PI / 180) / speed;
            X += (-keys.viewForward + keys.viewBackward) * Math.sin(RY * Math.PI / 180) / speed;
            
        }
        if (keys.viewLeft || keys.viewRight) { // 左右平移
            Z += (-keys.viewLeft + keys.viewRight) * Math.cos((RY + 90) * Math.PI / 180) / 10;
            X += (-keys.viewLeft + keys.viewRight) * Math.sin((RY + 90) * Math.PI / 180) / 10;
        }
        if (keys.viewUp || keys.viewDown) { // 上下平移
            var offset = (keys.viewUp - keys.viewDown) / 7;
            Y += offset;
        }
        if(keys.turnRight || keys.turnLeft) {  // 左右扭动
            var offset = (-keys.turnRight + keys.turnLeft);
            if(Math.abs(offset) > 0.1){
                RY += offset;
            }
        }
        if(keys.turnUp || keys.turnDown) {  // 上下扭动
            var offset = (-keys.turnUp + keys.turnDown);
            if(Math.abs(offset) > 0.5){
                RX += offset;
            }
        }
        return {  x: X,  y: Y,  z: Z,  rx: RX,  ry: RY,  rz: RZ  }
    },

    // 主角物理体
    mainVPlayer : null,

    // 摄像机的一些参数
    mainCamera : {
        groupName : null,
        pos : {  // 相对坐标系，相对于主角
            x: 0,
            y: 2.6,
            z: 7,
        },
        qua : {
            rx: 0,
            ry: 0,
            rz: 0,
        },
    },

    // 摄像机和主角的移动和旋转
    mainVPlayerMove : function(mainVPlayerObj){
        if(mainVPlayerObj === null){return};
        var cam = this.mainCamera;
        cam.groupName = mainVPlayerObj.name;
        var vplayerBodyPos = mainVPlayerObj.body.position;
        var vplayerBodyQua = mainVPlayerObj.body.quaternion;
        var vplayerAct = this.calMovePara(  // 获取按键和鼠标事件处理后的移动参数
            vplayerBodyPos.x, vplayerBodyPos.y, vplayerBodyPos.z,
            cam.qua.rx, cam.qua.ry, cam.qua.rz
        );
        mainVPlayerObj.body.position.x = vplayerAct.x;
        mainVPlayerObj.body.position.y = vplayerAct.y;
        mainVPlayerObj.body.position.z = vplayerAct.z;
        cam.qua = vplayerAct;
        vplayerBodyQua.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI / 180 * vplayerAct.ry);  // 主角只旋转 Y 轴
        W.camera({g:cam.groupName, x:cam.pos.x, y:cam.pos.y, z:cam.pos.z, rx: cam.qua.rx, rz: cam.qua.rz})  // 摄像机只旋转 X 和 Z 轴
        return 0;
        
    },

    // 进行一步物理世界的计算
    cannonAni : function(){
        this.world.step(1 / 60); // 时间步长 1/60，更新物理世界
    },

    // 动画循环
    animate : function(){
        var _this = this;
        var lastTime = performance.now();
        var frameCount = 0; // FPS 计数器
        const viewAnimate = function() {

            var currentTime = performance.now();
            var deltaTime = currentTime - lastTime;
            frameCount++;
            if(deltaTime > 1000){
                var fps = frameCount / (deltaTime / 1000);
                fpsInfo.innerHTML = ('<br>FPS: ' + fps.toFixed(2));
                frameCount = 0;
                lastTime = currentTime;
            }
            if(_this.mainVPlayer !== null){  // 调试使用
                posInfo.innerHTML = ('pos: x:' + Math.round(_this.mainVPlayer.body.position.x) + ' y:' + Math.round(_this.mainVPlayer.body.position.y) + ' z:' + Math.round(_this.mainVPlayer.body.position.z));
            }
            _this.cannonAni(); // 物理世界计算
            _this.updataBodylist(); // 更新物体列表
            _this.mainVPlayerMove(_this.mainVPlayer); // 摄像机和主角的移动和旋转
            requestAnimationFrame(viewAnimate);
        }
        viewAnimate();
    },
}

ccgxk.initWorld();



ccgxk.addPhysicalBox({  // 创建一个 测试 物理体
    name: 'test', X: -30, Y: 1, Z: -30,
    mass: 0, width: 10, depth: 15, height: 1, texture: marble
});

ccgxk.addPhysicalBox({  // 创建一个 旋转测试 细长物理体
    name: 'longThin', X: 20, Y: 1, Z: -30,
    mass: 1, width: 20, depth: 1, height: 1, texture: marble
});



ccgxk.addPhysicalBox({  // 创建地面
    name: 'groundPlane', X: 0, Y: 0, Z: 0,
    mass: 0, width: 200000, depth: 200000, height: 0.01,
    texture: marble, background: '#FFF', mixValue: 0.71
});




ccgxk.mainVPlayer = ccgxk.addPhysicalBox({  // 创建一个立方体，并设置为主角
    name: 'mainPlayer', X: 15, Y: 20, Z: 30,
    rX: 0, rY: 0, rZ: 0,
    mass: 5, texture: marble
});


function add10ranObj(number = 100){
    var yVlaue = 10;
    for(var i = 0; i < number; i++){  // 创建 10 个立方体
        ccgxk.addPhysicalBox({
            X: -Math.floor( Math.random() * 750 + 1), Y: yVlaue, Z: -Math.floor( Math.random() * 370 + 1),
            mass: 1, width: Math.floor( Math.random() * 30 + 1), depth: 5, height: Math.floor( Math.random() * 100 + 1),
            texture: marble, background: '#FFF', mixValue: 0.71
        });
    }
    console.log(ccgxk.bodylist.length);
}
add10ranObj();





/*笔记

1. 修改 mass：

ccgxk.bodylist[1].body.mass = 0
ccgxk.bodylist[1].body.updateMassProperties()  // 还要修改惯性张量

2. 物理迭代

当 MASS = 0，
物理迭代为 1 时，支持的最多的 mass=0 的 box 项目，约为 400~500 个
物理迭代为 10 时，和上面也差不多

当 MASS = 1，
物理迭代为 1 时，支持的最多的 mass=0 的 box 项目，约为 300 个

所以和 MASS 有关...

但也可能是 W.js 的原因

破案了，是 WJS 的原因

*/

/* 开始试验自定义面 */





</script>