"use strict";function DEFNODE(e,t,n,o){void 0===o&&(o=AST_Node);var i,a=t=t?t.split(/\s+/):[],s=(o&&o.PROPS&&(t=t.concat(o.PROPS)),["return function AST_",e,"(props){","this._bits=0;","if(props){"]),r=(t.forEach(function(e){s.push("this.",e,"=props.",e,";")}),s.push("}"),Object.create(o&&o.prototype)),l=((n.initialize||r.initialize)&&s.push("this.initialize();"),s.push("};"),new Function(s.join(""))());for(i in l.prototype=r,(l.prototype.CTOR=l).prototype.TYPE=l.TYPE=e,o&&(l.BASE=o).SUBCLASSES.push(l),l.DEFMETHOD=function(e,t){this.prototype[e]=t},l.PROPS=t,l.SELF_PROPS=a,l.SUBCLASSES=[],n)HOP(n,i)&&(/^\$/.test(i)?l[i.substr(1)]=n[i]:l.DEFMETHOD(i,n[i]));return"undefined"!=typeof exports&&(exports["AST_"+e]=l),l}var AST_Token=DEFNODE("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw",{},null),AST_Node=DEFNODE("Node","start end",{_clone:function(e){var t;return e?(t=this.clone()).transform(new TreeTransformer(function(e){if(e!==t)return e.clone(!0)})):new this.CTOR(this)},clone:function(e){return this._clone(e)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},equals:function(e){return this.TYPE==e.TYPE&&this._equals(e)},walk:function(e){e.visit(this)},_validate:function(){if("Node"==this.TYPE)throw new Error("should not instantiate AST_Node")},validate:function(){for(var e=this.CTOR;e.prototype._validate.call(this),e=e.BASE;);},validate_ast:function(){var t={};this.walk(new TreeWalker(function(e){if(e.validate_visited===t)throw new Error(string_template("cannot reuse AST_{TYPE} from [{start}]",e));e.validate_visited=t}))}},null),restore_transforms=(DEF_BITPROPS(AST_Node,["_optimized","_squeezed","call_only","collapse_scanning","defined","evaluating","falsy","in_arg","in_bool","is_undefined","inlined","length_read","nested","new","optional","private","pure","single_use","static","terminal","truthy","uses_eval","uses_with"]),(AST_Node.log_function=function(t,e){var n;function o(e){n[e]||(n[e]=!0,t(e))}"function"!=typeof t?AST_Node.info=AST_Node.warn=noop:(n=Object.create(null),AST_Node.info=e?function(e,t){o("INFO: "+string_template(e,t))}:noop,AST_Node.warn=function(e,t){o("WARN: "+string_template(e,t))})})(),[]);function all_equals(e,n){return e.length==n.length&&all(e,function(e,t){return e.equals(n[t])})}function list_equals(e,n){return e.length==n.length&&all(e,function(e,t){return e==n[t]})}function prop_equals(e,t){return e===t||(null==e?null==t:e instanceof AST_Node&&t instanceof AST_Node&&e.equals(t))}AST_Node.enable_validation=function(){AST_Node.disable_validation(),function e(t){var n;t.SUBCLASSES.forEach(e),HOP(t.prototype,"transform")&&(n=t.prototype.transform,t.prototype.transform=function(e,t){e=n.call(this,e,t);if(e instanceof AST_Node)e.validate();else if(!(null===e||t&&List.is_op(e)))throw new Error("invalid transformed value: "+e);return e},restore_transforms.push(function(){t.prototype.transform=n}))}(this)},AST_Node.disable_validation=function(){for(var e;e=restore_transforms.pop();)e()};var AST_Statement=DEFNODE("Statement",null,{$documentation:"Base class of all statements",_validate:function(){if("Statement"==this.TYPE)throw new Error("should not instantiate AST_Statement")}}),AST_Debugger=DEFNODE("Debugger",null,{$documentation:"Represents a debugger statement",_equals:return_true},AST_Statement),AST_Directive=DEFNODE("Directive","quote value",{$documentation:'Represents a directive, like "use strict";',$propdoc:{quote:"[string?] the original quote character",value:"[string] The value of this directive as a plain string (it's not an AST_String!)"},_equals:function(e){return this.value==e.value},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},AST_Statement),AST_EmptyStatement=DEFNODE("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_equals:return_true},AST_Statement);function is_statement(e){return e instanceof AST_Statement&&!(e instanceof AST_ClassExpression)&&!(e instanceof AST_LambdaExpression)}function validate_expression(e,t,n,o,i){if(n=n?"contain":"be",!(e instanceof AST_Node))throw new Error(t+" must "+n+" AST_Node");if(e instanceof AST_DefaultValue)throw new Error(t+" cannot "+n+" AST_DefaultValue");if(e instanceof AST_Destructured)throw new Error(t+" cannot "+n+" AST_Destructured");if(e instanceof AST_Hole&&!i)throw new Error(t+" cannot "+n+" AST_Hole");if(e instanceof AST_Spread&&!o)throw new Error(t+" cannot "+n+" AST_Spread");if(is_statement(e))throw new Error(t+" cannot "+n+" AST_Statement");if(e instanceof AST_SymbolDeclaration)throw new Error(t+" cannot "+n+" AST_SymbolDeclaration")}function must_be_expression(e,t){validate_expression(e[t],t)}var AST_SimpleStatement=DEFNODE("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_equals:function(e){return this.body.equals(e.body)},walk:function(e){var t=this;e.visit(t,function(){t.body.walk(e)})},_validate:function(){must_be_expression(this,"body")}},AST_Statement),AST_BlockScope=DEFNODE("BlockScope","_var_names enclosed functions make_def parent_scope variables",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any inner scopes",functions:"[Dictionary/S] like `variables`, but only lists function declarations",parent_scope:"[AST_Scope?/S] link to the parent scope",variables:"[Dictionary/S] a map of name ---\x3e SymbolDef for all variables/functions defined in this scope"},clone:function(e){e=this._clone(e);return this.enclosed&&(e.enclosed=this.enclosed.slice()),this.functions&&(e.functions=this.functions.clone()),this.variables&&(e.variables=this.variables.clone()),e},pinned:function(){return this.resolve().pinned()},resolve:function(){return this.parent_scope.resolve()},_validate:function(){if("BlockScope"==this.TYPE)throw new Error("should not instantiate AST_BlockScope");if(null!=this.parent_scope){if(!(this.parent_scope instanceof AST_BlockScope))throw new Error("parent_scope must be AST_BlockScope");if(!(this.resolve()instanceof AST_Scope))throw new Error("must be contained within AST_Scope")}}},AST_Statement);function walk_body(e,t){e.body.forEach(function(e){e.walk(t)})}var AST_Block=DEFNODE("Block","body",{$documentation:"A body of statements (usually braced)",$propdoc:{body:"[AST_Statement*] an array of statements"},_equals:function(e){return all_equals(this.body,e.body)},walk:function(e){var t=this;e.visit(t,function(){walk_body(t,e)})},_validate:function(){if("Block"==this.TYPE)throw new Error("should not instantiate AST_Block");this.body.forEach(function(e){if(!is_statement(e))throw new Error("body must contain AST_Statement")})}},AST_BlockScope),AST_BlockStatement=DEFNODE("BlockStatement",null,{$documentation:"A block statement"},AST_Block),AST_StatementWithBody=DEFNODE("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_validate:function(){if("StatementWithBody"==this.TYPE)throw new Error("should not instantiate AST_StatementWithBody");if(!is_statement(this.body))throw new Error("body must be AST_Statement")}},AST_BlockScope),AST_LabeledStatement=DEFNODE("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_equals:function(e){return this.label.equals(e.label)&&this.body.equals(e.body)},walk:function(e){var t=this;e.visit(t,function(){t.label.walk(e),t.body.walk(e)})},clone:function(e){var t,n,o=this._clone(e);return e&&(t=o.label,n=this.label,o.walk(new TreeWalker(function(e){return e instanceof AST_LoopControl?e.label&&e.label.thedef===n?((e.label.thedef=t).references.push(e),!0):void 0:e instanceof AST_Scope||void 0}))),o},_validate:function(){if(!(this.label instanceof AST_Label))throw new Error("label must be AST_Label")}},AST_StatementWithBody),AST_IterationStatement=DEFNODE("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it.",_validate:function(){if("IterationStatement"==this.TYPE)throw new Error("should not instantiate AST_IterationStatement")}},AST_StatementWithBody),AST_DWLoop=DEFNODE("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"},_equals:function(e){return this.body.equals(e.body)&&this.condition.equals(e.condition)},_validate:function(){if("DWLoop"==this.TYPE)throw new Error("should not instantiate AST_DWLoop");must_be_expression(this,"condition")}},AST_IterationStatement),AST_Do=DEFNODE("Do",null,{$documentation:"A `do` statement",walk:function(e){var t=this;e.visit(t,function(){t.body.walk(e),t.condition.walk(e)})}},AST_DWLoop),AST_While=DEFNODE("While",null,{$documentation:"A `while` statement",walk:function(e){var t=this;e.visit(t,function(){t.condition.walk(e),t.body.walk(e)})}},AST_DWLoop),AST_For=DEFNODE("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_equals:function(e){return prop_equals(this.init,e.init)&&prop_equals(this.condition,e.condition)&&prop_equals(this.step,e.step)&&this.body.equals(e.body)},walk:function(e){var t=this;e.visit(t,function(){t.init&&t.init.walk(e),t.condition&&t.condition.walk(e),t.step&&t.step.walk(e),t.body.walk(e)})},_validate:function(){if(null!=this.init){if(!(this.init instanceof AST_Node))throw new Error("init must be AST_Node");if(is_statement(this.init)&&!(this.init instanceof AST_Definitions))throw new Error("init cannot be AST_Statement")}null!=this.condition&&must_be_expression(this,"condition"),null!=this.step&&must_be_expression(this,"step")}},AST_IterationStatement),AST_ForEnumeration=DEFNODE("ForEnumeration","init object",{$documentation:"Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`",$propdoc:{init:"[AST_Node] the assignment target during iteration",object:"[AST_Node] the object to iterate over"},_equals:function(e){return this.init.equals(e.init)&&this.object.equals(e.object)&&this.body.equals(e.body)},walk:function(e){var t=this;e.visit(t,function(){t.init.walk(e),t.object.walk(e),t.body.walk(e)})},_validate:function(){if("ForEnumeration"==this.TYPE)throw new Error("should not instantiate AST_ForEnumeration");if(this.init instanceof AST_Definitions){if(1!=this.init.definitions.length)throw new Error("init must have single declaration")}else validate_destructured(this.init,function(e){if(!(e instanceof AST_PropAccess||e instanceof AST_SymbolRef))throw new Error("init must be assignable: "+e.TYPE)});must_be_expression(this,"object")}},AST_IterationStatement),AST_ForIn=DEFNODE("ForIn",null,{$documentation:"A `for ... in` statement"},AST_ForEnumeration),AST_ForOf=DEFNODE("ForOf",null,{$documentation:"A `for ... of` statement"},AST_ForEnumeration),AST_ForAwaitOf=DEFNODE("ForAwaitOf",null,{$documentation:"A `for await ... of` statement"},AST_ForOf),AST_With=DEFNODE("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_equals:function(e){return this.expression.equals(e.expression)&&this.body.equals(e.body)},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e),t.body.walk(e)})},_validate:function(){must_be_expression(this,"expression")}},AST_StatementWithBody),AST_Scope=DEFNODE("Scope","fn_defs may_call_this uses_eval uses_with",{$documentation:"Base class for all statements introducing a lambda scope",$propdoc:{uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",uses_with:"[boolean/S] tells whether this scope uses the `with` statement"},pinned:function(){return this.uses_eval||this.uses_with},resolve:return_this,_validate:function(){if("Scope"==this.TYPE)throw new Error("should not instantiate AST_Scope")}},AST_Block),AST_Toplevel=DEFNODE("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Dictionary/S] a map of name ---\x3e SymbolDef for all undeclared names"},wrap:function(e){var t=this.body;return parse(["(function(exports){'$ORIG';})(typeof ",e,"=='undefined'?(",e,"={}):",e,");"].join(""),{filename:"wrap="+JSON.stringify(e)}).transform(new TreeTransformer(function(e){if(e instanceof AST_Directive&&"$ORIG"==e.value)return List.splice(t)}))},enclose:function(e){var t=(e="string"!=typeof e?"":e).indexOf(":"),n=(t<0&&(t=e.length),this.body);return parse(["(function(",e.slice(0,t),'){"$ORIG"})(',e.slice(t+1),")"].join(""),{filename:"enclose="+JSON.stringify(e)}).transform(new TreeTransformer(function(e){if(e instanceof AST_Directive&&"$ORIG"==e.value)return List.splice(n)}))}},AST_Scope),AST_ClassInitBlock=DEFNODE("ClassInitBlock",null,{$documentation:"Value for `class` static initialization blocks"},AST_Scope),AST_Lambda=DEFNODE("Lambda","argnames length_read rest safe_ids uses_arguments",{$documentation:"Base class for functions",$propdoc:{argnames:"[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals",length_read:"[boolean/S] whether length property of this function is accessed",rest:"[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent",uses_arguments:"[boolean|number/S] whether this function accesses the arguments array"},each_argname:function(t){var n=new TreeWalker(function(e){return e instanceof AST_DefaultValue?(e.name.walk(n),!0):e instanceof AST_DestructuredKeyVal?(e.value.walk(n),!0):void(e instanceof AST_SymbolFunarg&&t(e))});this.argnames.forEach(function(e){e.walk(n)}),this.rest&&this.rest.walk(n)},_equals:function(e){return prop_equals(this.rest,e.rest)&&prop_equals(this.name,e.name)&&prop_equals(this.value,e.value)&&all_equals(this.argnames,e.argnames)&&all_equals(this.body,e.body)},walk:function(t){var e=this;t.visit(e,function(){e.name&&e.name.walk(t),e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),walk_body(e,t)})},_validate:function(){if("Lambda"==this.TYPE)throw new Error("should not instantiate AST_Lambda");this.argnames.forEach(function(e){validate_destructured(e,function(e){if(!(e instanceof AST_SymbolFunarg))throw new Error("argnames must be AST_SymbolFunarg[]")},!0)}),null!=this.rest&&validate_destructured(this.rest,function(e){if(!(e instanceof AST_SymbolFunarg))throw new Error("rest must be AST_SymbolFunarg")})}},AST_Scope),AST_Accessor=DEFNODE("Accessor",null,{$documentation:"A getter/setter function",_validate:function(){if(null!=this.name)throw new Error("name must be null")}},AST_Lambda),AST_LambdaExpression=DEFNODE("LambdaExpression","inlined",{$documentation:"Base class for function expressions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined"},_validate:function(){if("LambdaExpression"==this.TYPE)throw new Error("should not instantiate AST_LambdaExpression")}},AST_Lambda);function is_arrow(e){return e instanceof AST_Arrow||e instanceof AST_AsyncArrow}function is_async(e){return e instanceof AST_AsyncArrow||e instanceof AST_AsyncDefun||e instanceof AST_AsyncFunction||e instanceof AST_AsyncGeneratorDefun||e instanceof AST_AsyncGeneratorFunction}function is_generator(e){return e instanceof AST_AsyncGeneratorDefun||e instanceof AST_AsyncGeneratorFunction||e instanceof AST_GeneratorDefun||e instanceof AST_GeneratorFunction}function walk_lambda(e,t){is_arrow(e)&&e.value?e.value.walk(t):walk_body(e,t)}var AST_Arrow=DEFNODE("Arrow","value",{$documentation:"An arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(t){var e=this;t.visit(e,function(){e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),e.value?e.value.walk(t):walk_body(e,t)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(must_be_expression(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},AST_LambdaExpression),AST_AsyncArrow=DEFNODE("AsyncArrow","value",{$documentation:"An asynchronous arrow function expression",$propdoc:{value:"[AST_Node?] simple return expression, or null if using function body."},walk:function(t){var e=this;t.visit(e,function(){e.argnames.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t),e.value?e.value.walk(t):walk_body(e,t)})},_validate:function(){if(null!=this.name)throw new Error("name must be null");if(this.uses_arguments)throw new Error("uses_arguments must be false");if(null!=this.value&&(must_be_expression(this,"value"),this.body.length))throw new Error("body must be empty if value exists")}},AST_LambdaExpression),AST_AsyncFunction=DEFNODE("AsyncFunction","name",{$documentation:"An asynchronous function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda")}},AST_LambdaExpression),AST_AsyncGeneratorFunction=DEFNODE("AsyncGeneratorFunction","name",{$documentation:"An asynchronous generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda")}},AST_LambdaExpression),AST_Function=DEFNODE("Function","name",{$documentation:"A function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda")}},AST_LambdaExpression),AST_GeneratorFunction=DEFNODE("GeneratorFunction","name",{$documentation:"A generator function expression",$propdoc:{name:"[AST_SymbolLambda?] the name of this function, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof AST_SymbolLambda))throw new Error("name must be AST_SymbolLambda")}},AST_LambdaExpression),AST_LambdaDefinition=DEFNODE("LambdaDefinition","inlined name",{$documentation:"Base class for function definitions",$propdoc:{inlined:"[boolean/S] whether this function has been inlined",name:"[AST_SymbolDefun] the name of this function"},_validate:function(){if("LambdaDefinition"==this.TYPE)throw new Error("should not instantiate AST_LambdaDefinition");if(!(this.name instanceof AST_SymbolDefun))throw new Error("name must be AST_SymbolDefun")}},AST_Lambda),AST_AsyncDefun=DEFNODE("AsyncDefun",null,{$documentation:"An asynchronous function definition"},AST_LambdaDefinition),AST_AsyncGeneratorDefun=DEFNODE("AsyncGeneratorDefun",null,{$documentation:"An asynchronous generator function definition"},AST_LambdaDefinition),AST_Defun=DEFNODE("Defun",null,{$documentation:"A function definition"},AST_LambdaDefinition),AST_GeneratorDefun=DEFNODE("GeneratorDefun",null,{$documentation:"A generator function definition"},AST_LambdaDefinition),AST_Class=DEFNODE("Class","extends name properties",{$documentation:"Base class for class literals",$propdoc:{extends:"[AST_Node?] the super class, or null if not specified",properties:"[AST_ClassProperty*] array of class properties"},_equals:function(e){return prop_equals(this.name,e.name)&&prop_equals(this.extends,e.extends)&&all_equals(this.properties,e.properties)},resolve:function(e){return e?this:this.parent_scope.resolve()},walk:function(t){var e=this;t.visit(e,function(){e.name&&e.name.walk(t),e.extends&&e.extends.walk(t),e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){if("Class"==this.TYPE)throw new Error("should not instantiate AST_Class");null!=this.extends&&must_be_expression(this,"extends"),this.properties.forEach(function(e){if(!(e instanceof AST_ClassProperty))throw new Error("properties must contain AST_ClassProperty")})}},AST_BlockScope),AST_DefClass=DEFNODE("DefClass",null,{$documentation:"A class definition",$propdoc:{name:"[AST_SymbolDefClass] the name of this class"},_validate:function(){if(!(this.name instanceof AST_SymbolDefClass))throw new Error("name must be AST_SymbolDefClass")}},AST_Class),AST_ClassExpression=DEFNODE("ClassExpression",null,{$documentation:"A class expression",$propdoc:{name:"[AST_SymbolClass?] the name of this class, or null if not specified"},_validate:function(){if(null!=this.name&&!(this.name instanceof AST_SymbolClass))throw new Error("name must be AST_SymbolClass")}},AST_Class),AST_ClassProperty=DEFNODE("ClassProperty","key private static value",{$documentation:"Base class for `class` properties",$propdoc:{key:"[string|AST_Node?] property name (AST_Node for computed property, null for initialization block)",private:"[boolean] whether this is a private property",static:"[boolean] whether this is a static property",value:"[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)"},_equals:function(e){return!this.private==!e.private&&!this.static==!e.static&&prop_equals(this.key,e.key)&&prop_equals(this.value,e.value)},walk:function(e){var t=this;e.visit(t,function(){t.key instanceof AST_Node&&t.key.walk(e),t.value&&t.value.walk(e)})},_validate:function(){if("ClassProperty"==this.TYPE)throw new Error("should not instantiate AST_ClassProperty");if(this instanceof AST_ClassInit){if(null!=this.key)throw new Error("key must be null")}else if("string"!=typeof this.key){if(!(this.key instanceof AST_Node))throw new Error("key must be string or AST_Node");if(this.private)throw new Error("computed key cannot be private");must_be_expression(this,"key")}else if(this.private&&!/^#/.test(this.key))throw new Error("private key must prefix with #");if(null!=this.value&&!(this.value instanceof AST_Node))throw new Error("value must be AST_Node")}}),AST_ClassField=DEFNODE("ClassField",null,{$documentation:"A `class` field",_validate:function(){null!=this.value&&must_be_expression(this,"value")}},AST_ClassProperty),AST_ClassGetter=DEFNODE("ClassGetter",null,{$documentation:"A `class` getter",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor")}},AST_ClassProperty),AST_ClassSetter=DEFNODE("ClassSetter",null,{$documentation:"A `class` setter",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor")}},AST_ClassProperty),AST_ClassMethod=DEFNODE("ClassMethod",null,{$documentation:"A `class` method",_validate:function(){if(!(this.value instanceof AST_LambdaExpression))throw new Error("value must be AST_LambdaExpression");if(is_arrow(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of class method's lambda must be null")}},AST_ClassProperty),AST_ClassInit=DEFNODE("ClassInit",null,{$documentation:"A `class` static initialization block",_validate:function(){if(!this.static)throw new Error("static must be true");if(!(this.value instanceof AST_ClassInitBlock))throw new Error("value must be AST_ClassInitBlock")},initialize:function(){this.static=!0}},AST_ClassProperty),AST_Jump=DEFNODE("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)",_validate:function(){if("Jump"==this.TYPE)throw new Error("should not instantiate AST_Jump")}},AST_Statement),AST_Exit=DEFNODE("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_equals:function(e){return prop_equals(this.value,e.value)},walk:function(e){var t=this;e.visit(t,function(){t.value&&t.value.walk(e)})},_validate:function(){if("Exit"==this.TYPE)throw new Error("should not instantiate AST_Exit")}},AST_Jump),AST_Return=DEFNODE("Return",null,{$documentation:"A `return` statement",_validate:function(){null!=this.value&&must_be_expression(this,"value")}},AST_Exit),AST_Throw=DEFNODE("Throw",null,{$documentation:"A `throw` statement",_validate:function(){must_be_expression(this,"value")}},AST_Exit),AST_LoopControl=DEFNODE("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_equals:function(e){return prop_equals(this.label,e.label)},walk:function(e){var t=this;e.visit(t,function(){t.label&&t.label.walk(e)})},_validate:function(){if("LoopControl"==this.TYPE)throw new Error("should not instantiate AST_LoopControl");if(null!=this.label&&!(this.label instanceof AST_LabelRef))throw new Error("label must be AST_LabelRef")}},AST_Jump),AST_Break=DEFNODE("Break",null,{$documentation:"A `break` statement"},AST_LoopControl),AST_Continue=DEFNODE("Continue",null,{$documentation:"A `continue` statement"},AST_LoopControl),AST_If=DEFNODE("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_equals:function(e){return this.body.equals(e.body)&&this.condition.equals(e.condition)&&prop_equals(this.alternative,e.alternative)},walk:function(e){var t=this;e.visit(t,function(){t.condition.walk(e),t.body.walk(e),t.alternative&&t.alternative.walk(e)})},_validate:function(){if(must_be_expression(this,"condition"),null!=this.alternative&&!is_statement(this.alternative))throw new Error("alternative must be AST_Statement")}},AST_StatementWithBody),AST_Switch=DEFNODE("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_equals:function(e){return this.expression.equals(e.expression)&&all_equals(this.body,e.body)},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e),walk_body(t,e)})},_validate:function(){must_be_expression(this,"expression"),this.body.forEach(function(e){if(!(e instanceof AST_SwitchBranch))throw new Error("body must be AST_SwitchBranch[]")})}},AST_Block),AST_SwitchBranch=DEFNODE("SwitchBranch",null,{$documentation:"Base class for `switch` branches",_validate:function(){if("SwitchBranch"==this.TYPE)throw new Error("should not instantiate AST_SwitchBranch")}},AST_Block),AST_Default=DEFNODE("Default",null,{$documentation:"A `default` switch branch"},AST_SwitchBranch),AST_Case=DEFNODE("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_equals:function(e){return this.expression.equals(e.expression)&&all_equals(this.body,e.body)},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e),walk_body(t,e)})},_validate:function(){must_be_expression(this,"expression")}},AST_SwitchBranch),AST_Try=DEFNODE("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_equals:function(e){return all_equals(this.body,e.body)&&prop_equals(this.bcatch,e.bcatch)&&prop_equals(this.bfinally,e.bfinally)},walk:function(e){var t=this;e.visit(t,function(){walk_body(t,e),t.bcatch&&t.bcatch.walk(e),t.bfinally&&t.bfinally.walk(e)})},_validate:function(){if(null!=this.bcatch&&!(this.bcatch instanceof AST_Catch))throw new Error("bcatch must be AST_Catch");if(null!=this.bfinally&&!(this.bfinally instanceof AST_Finally))throw new Error("bfinally must be AST_Finally")}},AST_Block),AST_Catch=DEFNODE("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present"},_equals:function(e){return prop_equals(this.argname,e.argname)&&all_equals(this.body,e.body)},walk:function(e){var t=this;e.visit(t,function(){t.argname&&t.argname.walk(e),walk_body(t,e)})},_validate:function(){null!=this.argname&&validate_destructured(this.argname,function(e){if(!(e instanceof AST_SymbolCatch))throw new Error("argname must be AST_SymbolCatch")})}},AST_Block),AST_Finally=DEFNODE("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},AST_Block),AST_Definitions=DEFNODE("Definitions","definitions",{$documentation:"Base class for `var` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_equals:function(e){return all_equals(this.definitions,e.definitions)},walk:function(t){var e=this;t.visit(e,function(){e.definitions.forEach(function(e){e.walk(t)})})},_validate:function(){if("Definitions"==this.TYPE)throw new Error("should not instantiate AST_Definitions");if(this.definitions.length<1)throw new Error("must have at least one definition")}},AST_Statement),AST_Const=DEFNODE("Const",null,{$documentation:"A `const` statement",_validate:function(){this.definitions.forEach(function(e){if(!(e instanceof AST_VarDef))throw new Error("definitions must be AST_VarDef[]");validate_destructured(e.name,function(e){if(!(e instanceof AST_SymbolConst))throw new Error("name must be AST_SymbolConst")})})}},AST_Definitions),AST_Let=DEFNODE("Let",null,{$documentation:"A `let` statement",_validate:function(){this.definitions.forEach(function(e){if(!(e instanceof AST_VarDef))throw new Error("definitions must be AST_VarDef[]");validate_destructured(e.name,function(e){if(!(e instanceof AST_SymbolLet))throw new Error("name must be AST_SymbolLet")})})}},AST_Definitions),AST_Var=DEFNODE("Var",null,{$documentation:"A `var` statement",_validate:function(){this.definitions.forEach(function(e){if(!(e instanceof AST_VarDef))throw new Error("definitions must be AST_VarDef[]");validate_destructured(e.name,function(e){if(!(e instanceof AST_SymbolVar))throw new Error("name must be AST_SymbolVar")})})}},AST_Definitions),AST_VarDef=DEFNODE("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_Destructured|AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_equals:function(e){return this.name.equals(e.name)&&prop_equals(this.value,e.value)},walk:function(e){var t=this;e.visit(t,function(){t.name.walk(e),t.value&&t.value.walk(e)})},_validate:function(){null!=this.value&&must_be_expression(this,"value")}}),AST_ExportDeclaration=DEFNODE("ExportDeclaration","body",{$documentation:"An `export` statement",$propdoc:{body:"[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export"},_equals:function(e){return this.body.equals(e.body)},walk:function(e){var t=this;e.visit(t,function(){t.body.walk(e)})},_validate:function(){if(!(this.body instanceof AST_DefClass||this.body instanceof AST_Definitions||this.body instanceof AST_LambdaDefinition))throw new Error("body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition")}},AST_Statement),AST_ExportDefault=DEFNODE("ExportDefault","body",{$documentation:"An `export default` statement",$propdoc:{body:"[AST_Node] the default export"},_equals:function(e){return this.body.equals(e.body)},walk:function(e){var t=this;e.visit(t,function(){t.body.walk(e)})},_validate:function(){this.body instanceof AST_DefClass||this.body instanceof AST_LambdaDefinition||must_be_expression(this,"body")}},AST_Statement),AST_ExportForeign=DEFNODE("ExportForeign","aliases keys path",{$documentation:"An `export ... from '...'` statement",$propdoc:{aliases:"[AST_String*] array of aliases to export",keys:"[AST_String*] array of keys to import",path:"[AST_String] the path to import module"},_equals:function(e){return this.path.equals(e.path)&&all_equals(this.aliases,e.aliases)&&all_equals(this.keys,e.keys)},_validate:function(){if(this.aliases.length!=this.keys.length)throw new Error("aliases:key length mismatch: "+this.aliases.length+" != "+this.keys.length);if(this.aliases.forEach(function(e){if(!(e instanceof AST_String))throw new Error("aliases must contain AST_String")}),this.keys.forEach(function(e){if(!(e instanceof AST_String))throw new Error("keys must contain AST_String")}),!(this.path instanceof AST_String))throw new Error("path must be AST_String")}},AST_Statement),AST_ExportReferences=DEFNODE("ExportReferences","properties",{$documentation:"An `export { ... }` statement",$propdoc:{properties:"[AST_SymbolExport*] array of aliases to export"},_equals:function(e){return all_equals(this.properties,e.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){this.properties.forEach(function(e){if(!(e instanceof AST_SymbolExport))throw new Error("properties must contain AST_SymbolExport")})}},AST_Statement),AST_Import=DEFNODE("Import","all default path properties",{$documentation:"An `import` statement",$propdoc:{all:"[AST_SymbolImport?] the imported namespace, or null if not specified",default:"[AST_SymbolImport?] the alias for default `export`, or null if not specified",path:"[AST_String] the path to import module",properties:"[(AST_SymbolImport*)?] array of aliases, or null if not specified"},_equals:function(e){return this.path.equals(e.path)&&prop_equals(this.all,e.all)&&prop_equals(this.default,e.default)&&!this.properties==!e.properties&&(!this.properties||all_equals(this.properties,e.properties))},walk:function(t){var e=this;t.visit(e,function(){e.all&&e.all.walk(t),e.default&&e.default.walk(t),e.properties&&e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){if(null!=this.all){if(!(this.all instanceof AST_SymbolImport))throw new Error("all must be AST_SymbolImport");if(null!=this.properties)throw new Error("cannot import both * and {} in the same statement")}if(null!=this.default){if(!(this.default instanceof AST_SymbolImport))throw new Error("default must be AST_SymbolImport");if(""!==this.default.key.value)throw new Error("invalid default key: "+this.default.key.value)}if(!(this.path instanceof AST_String))throw new Error("path must be AST_String");null!=this.properties&&this.properties.forEach(function(e){if(!(e instanceof AST_SymbolImport))throw new Error("properties must contain AST_SymbolImport")})}},AST_Statement),AST_DefaultValue=DEFNODE("DefaultValue","name value",{$documentation:"A default value declaration",$propdoc:{name:"[AST_Destructured|AST_SymbolDeclaration] name of the variable",value:"[AST_Node] value to assign if variable is `undefined`"},_equals:function(e){return this.name.equals(e.name)&&this.value.equals(e.value)},walk:function(e){var t=this;e.visit(t,function(){t.name.walk(e),t.value.walk(e)})},_validate:function(){must_be_expression(this,"value")}});function must_be_expressions(e,t,n,o){e[t].forEach(function(e){validate_expression(e,t,!0,n,o)})}var AST_Call=DEFNODE("Call","args expression optional pure terminal",{$documentation:"A function call expression",$propdoc:{args:"[AST_Node*] array of arguments",expression:"[AST_Node] expression to invoke as function",optional:"[boolean] whether the expression is optional chaining",pure:"[boolean/S] marker for side-effect-free call expression",terminal:"[boolean] whether the chain has ended"},_equals:function(e){return!this.optional==!e.optional&&this.expression.equals(e.expression)&&all_equals(this.args,e.args)},walk:function(t){var e=this;t.visit(e,function(){e.expression.walk(t),e.args.forEach(function(e){e.walk(t)})})},_validate:function(){must_be_expression(this,"expression"),must_be_expressions(this,"args",!0)}}),AST_New=DEFNODE("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties",_validate:function(){if(this.optional)throw new Error("optional must be false");if(this.terminal)throw new Error("terminal must be false")}},AST_Call),AST_Sequence=DEFNODE("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_equals:function(e){return all_equals(this.expressions,e.expressions)},walk:function(t){var e=this;t.visit(e,function(){e.expressions.forEach(function(e){e.walk(t)})})},_validate:function(){if(this.expressions.length<2)throw new Error("expressions must contain multiple elements");must_be_expressions(this,"expressions")}});function root_expr(e){for(;e instanceof AST_PropAccess;)e=e.expression;return e}var AST_PropAccess=DEFNODE("PropAccess","expression optional property terminal",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",optional:"[boolean] whether the expression is optional chaining",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node",terminal:"[boolean] whether the chain has ended"},_equals:function(e){return!this.optional==!e.optional&&prop_equals(this.property,e.property)&&this.expression.equals(e.expression)},get_property:function(){var e=this.property;return e instanceof AST_Constant?e.value:e instanceof AST_UnaryPrefix&&"void"==e.operator&&e.expression instanceof AST_Constant?void 0:e},_validate:function(){if("PropAccess"==this.TYPE)throw new Error("should not instantiate AST_PropAccess");must_be_expression(this,"expression")}}),AST_Dot=DEFNODE("Dot","quoted",{$documentation:"A dotted property access expression",$propdoc:{quoted:"[boolean] whether property is transformed from a quoted string"},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e)})},_validate:function(){if("string"!=typeof this.property)throw new Error("property must be string")}},AST_PropAccess),AST_Sub=DEFNODE("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e),t.property.walk(e)})},_validate:function(){must_be_expression(this,"property")}},AST_PropAccess),AST_Spread=DEFNODE("Spread","expression",{$documentation:"Spread expression in array/object literals or function calls",$propdoc:{expression:"[AST_Node] expression to be expanded"},_equals:function(e){return this.expression.equals(e.expression)},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e)})},_validate:function(){must_be_expression(this,"expression")}}),AST_Unary=DEFNODE("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_equals:function(e){return this.operator==e.operator&&this.expression.equals(e.expression)},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e)})},_validate:function(){if("Unary"==this.TYPE)throw new Error("should not instantiate AST_Unary");if("string"!=typeof this.operator)throw new Error("operator must be string");must_be_expression(this,"expression")}}),AST_UnaryPrefix=DEFNODE("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},AST_Unary),AST_UnaryPostfix=DEFNODE("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},AST_Unary),AST_Binary=DEFNODE("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_equals:function(e){return this.operator==e.operator&&this.left.equals(e.left)&&this.right.equals(e.right)},walk:function(e){var t=this;e.visit(t,function(){t.left.walk(e),t.right.walk(e)})},_validate:function(){if(this instanceof AST_Assign||must_be_expression(this,"left"),"string"!=typeof this.operator)throw new Error("operator must be string");must_be_expression(this,"right")}}),AST_Conditional=DEFNODE("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_equals:function(e){return this.condition.equals(e.condition)&&this.consequent.equals(e.consequent)&&this.alternative.equals(e.alternative)},walk:function(e){var t=this;e.visit(t,function(){t.condition.walk(e),t.consequent.walk(e),t.alternative.walk(e)})},_validate:function(){must_be_expression(this,"condition"),must_be_expression(this,"consequent"),must_be_expression(this,"alternative")}}),AST_Assign=DEFNODE("Assign",null,{$documentation:"An assignment expression — `a = b + 5`",_validate:function(){if(this.operator.indexOf("=")<0)throw new Error('operator must contain "="');if(this.left instanceof AST_Destructured){if("="!=this.operator)throw new Error("invalid destructuring operator: "+this.operator);validate_destructured(this.left,function(e){if(!(e instanceof AST_PropAccess||e instanceof AST_SymbolRef))throw new Error("left must be assignable: "+e.TYPE)})}else if(!(this.left instanceof AST_Infinity||this.left instanceof AST_NaN||this.left instanceof AST_PropAccess&&!this.left.optional||this.left instanceof AST_SymbolRef||this.left instanceof AST_Undefined))throw new Error("left must be assignable")}},AST_Binary),AST_Await=DEFNODE("Await","expression",{$documentation:"An await expression",$propdoc:{expression:"[AST_Node] expression with Promise to resolve on"},_equals:function(e){return this.expression.equals(e.expression)},walk:function(e){var t=this;e.visit(t,function(){t.expression.walk(e)})},_validate:function(){must_be_expression(this,"expression")}}),AST_Yield=DEFNODE("Yield","expression nested",{$documentation:"A yield expression",$propdoc:{expression:"[AST_Node?] return value for iterator, or null if undefined",nested:"[boolean] whether to iterate over expression as generator"},_equals:function(e){return!this.nested==!e.nested&&prop_equals(this.expression,e.expression)},walk:function(e){var t=this;e.visit(t,function(){t.expression&&t.expression.walk(e)})},_validate:function(){if(null!=this.expression)must_be_expression(this,"expression");else if(this.nested)throw new Error("yield* must contain expression")}}),AST_Array=DEFNODE("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_equals:function(e){return all_equals(this.elements,e.elements)},walk:function(t){var e=this;t.visit(e,function(){e.elements.forEach(function(e){e.walk(t)})})},_validate:function(){must_be_expressions(this,"elements",!0,!0)}}),AST_Destructured=DEFNODE("Destructured","rest",{$documentation:"Base class for destructured literal",$propdoc:{rest:"[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent"},_validate:function(){if("Destructured"==this.TYPE)throw new Error("should not instantiate AST_Destructured")}});function validate_destructured(e,t,n){if(e instanceof AST_DefaultValue&&n)return validate_destructured(e.name,t);if(e instanceof AST_Destructured){if(null!=e.rest&&validate_destructured(e.rest,t),e instanceof AST_DestructuredArray)return e.elements.forEach(function(e){e instanceof AST_Hole||validate_destructured(e,t,!0)});if(e instanceof AST_DestructuredObject)return e.properties.forEach(function(e){validate_destructured(e.value,t,!0)})}t(e)}var AST_DestructuredArray=DEFNODE("DestructuredArray","elements",{$documentation:"A destructured array literal",$propdoc:{elements:"[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements"},_equals:function(e){return prop_equals(this.rest,e.rest)&&all_equals(this.elements,e.elements)},walk:function(t){var e=this;t.visit(e,function(){e.elements.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t)})}},AST_Destructured),AST_DestructuredKeyVal=DEFNODE("DestructuredKeyVal","key value",{$documentation:"A key: value destructured property",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value"},_equals:function(e){return prop_equals(this.key,e.key)&&this.value.equals(e.value)},walk:function(e){var t=this;e.visit(t,function(){t.key instanceof AST_Node&&t.key.walk(e),t.value.walk(e)})},_validate:function(){if("string"!=typeof this.key){if(!(this.key instanceof AST_Node))throw new Error("key must be string or AST_Node");must_be_expression(this,"key")}if(!(this.value instanceof AST_Node))throw new Error("value must be AST_Node")}}),AST_DestructuredObject=DEFNODE("DestructuredObject","properties",{$documentation:"A destructured object literal",$propdoc:{properties:"[AST_DestructuredKeyVal*] array of properties"},_equals:function(e){return prop_equals(this.rest,e.rest)&&all_equals(this.properties,e.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)}),e.rest&&e.rest.walk(t)})},_validate:function(){this.properties.forEach(function(e){if(!(e instanceof AST_DestructuredKeyVal))throw new Error("properties must be AST_DestructuredKeyVal[]")})}},AST_Destructured),AST_Object=DEFNODE("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[(AST_ObjectProperty|AST_Spread)*] array of properties"},_equals:function(e){return all_equals(this.properties,e.properties)},walk:function(t){var e=this;t.visit(e,function(){e.properties.forEach(function(e){e.walk(t)})})},_validate:function(){this.properties.forEach(function(e){if(!(e instanceof AST_ObjectProperty||e instanceof AST_Spread))throw new Error("properties must contain AST_ObjectProperty and/or AST_Spread only")})}}),AST_ObjectProperty=DEFNODE("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name.  For computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_equals:function(e){return prop_equals(this.key,e.key)&&this.value.equals(e.value)},walk:function(e){var t=this;e.visit(t,function(){t.key instanceof AST_Node&&t.key.walk(e),t.value.walk(e)})},_validate:function(){if("ObjectProperty"==this.TYPE)throw new Error("should not instantiate AST_ObjectProperty");if("string"!=typeof this.key){if(!(this.key instanceof AST_Node))throw new Error("key must be string or AST_Node");must_be_expression(this,"key")}if(!(this.value instanceof AST_Node))throw new Error("value must be AST_Node")}}),AST_ObjectKeyVal=DEFNODE("ObjectKeyVal",null,{$documentation:"A key: value object property",_validate:function(){must_be_expression(this,"value")}},AST_ObjectProperty),AST_ObjectMethod=DEFNODE("ObjectMethod",null,{$documentation:"A key(){} object property",_validate:function(){if(!(this.value instanceof AST_LambdaExpression))throw new Error("value must be AST_LambdaExpression");if(is_arrow(this.value))throw new Error("value cannot be AST_Arrow or AST_AsyncArrow");if(null!=this.value.name)throw new Error("name of object method's lambda must be null")}},AST_ObjectKeyVal),AST_ObjectSetter=DEFNODE("ObjectSetter",null,{$documentation:"An object setter property",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor")}},AST_ObjectProperty),AST_ObjectGetter=DEFNODE("ObjectGetter",null,{$documentation:"An object getter property",_validate:function(){if(!(this.value instanceof AST_Accessor))throw new Error("value must be AST_Accessor")}},AST_ObjectProperty),AST_Symbol=DEFNODE("Symbol","scope name thedef",{$documentation:"Base class for all symbols",$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},_equals:function(e){return this.thedef?this.thedef===e.thedef:this.name==e.name},_validate:function(){if("Symbol"==this.TYPE)throw new Error("should not instantiate AST_Symbol");if("string"!=typeof this.name)throw new Error("name must be string")}}),AST_SymbolDeclaration=DEFNODE("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var, function name or argument, symbol in catch)"},AST_Symbol),AST_SymbolConst=DEFNODE("SymbolConst",null,{$documentation:"Symbol defining a constant"},AST_SymbolDeclaration),AST_SymbolImport=DEFNODE("SymbolImport","key",{$documentation:"Symbol defined by an `import` statement",$propdoc:{key:"[AST_String] the original `export` name"},_equals:function(e){return this.name==e.name&&this.key.equals(e.key)},_validate:function(){if(!(this.key instanceof AST_String))throw new Error("key must be AST_String")}},AST_SymbolConst),AST_SymbolLet=DEFNODE("SymbolLet",null,{$documentation:"Symbol defining a lexical-scoped variable"},AST_SymbolDeclaration),AST_SymbolVar=DEFNODE("SymbolVar",null,{$documentation:"Symbol defining a variable"},AST_SymbolDeclaration),AST_SymbolFunarg=DEFNODE("SymbolFunarg","unused",{$documentation:"Symbol naming a function argument"},AST_SymbolVar),AST_SymbolDefun=DEFNODE("SymbolDefun",null,{$documentation:"Symbol defining a function"},AST_SymbolDeclaration),AST_SymbolLambda=DEFNODE("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},AST_SymbolDeclaration),AST_SymbolDefClass=DEFNODE("SymbolDefClass",null,{$documentation:"Symbol defining a class"},AST_SymbolConst),AST_SymbolClass=DEFNODE("SymbolClass",null,{$documentation:"Symbol naming a class expression"},AST_SymbolConst),AST_SymbolCatch=DEFNODE("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},AST_SymbolDeclaration),AST_Label=DEFNODE("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},AST_Symbol),AST_SymbolRef=DEFNODE("SymbolRef","fixed in_arg redef",{$documentation:"Reference to some symbol (not definition/declaration)"},AST_Symbol),AST_SymbolExport=DEFNODE("SymbolExport","alias",{$documentation:"Reference in an `export` statement",$propdoc:{alias:"[AST_String] the `export` alias"},_equals:function(e){return this.name==e.name&&this.alias.equals(e.alias)},_validate:function(){if(!(this.alias instanceof AST_String))throw new Error("alias must be AST_String")}},AST_SymbolRef),AST_LabelRef=DEFNODE("LabelRef",null,{$documentation:"Reference to a label symbol"},AST_Symbol),AST_ObjectIdentity=DEFNODE("ObjectIdentity",null,{$documentation:"Base class for `super` & `this`",_equals:return_true,_validate:function(){if("ObjectIdentity"==this.TYPE)throw new Error("should not instantiate AST_ObjectIdentity")}},AST_Symbol),AST_Super=DEFNODE("Super",null,{$documentation:"The `super` symbol",_validate:function(){if("super"!==this.name)throw new Error('name must be "super"')}},AST_ObjectIdentity),AST_This=DEFNODE("This",null,{$documentation:"The `this` symbol",_validate:function(){if("This"==this.TYPE&&"this"!==this.name)throw new Error('name must be "this"')}},AST_ObjectIdentity),AST_NewTarget=DEFNODE("NewTarget",null,{$documentation:"The `new.target` symbol",initialize:function(){this.name="new.target"},_validate:function(){if("new.target"!==this.name)throw new Error('name must be "new.target": '+this.name)}},AST_This),AST_Template=DEFNODE("Template","expressions strings tag",{$documentation:"A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`",$propdoc:{expressions:"[AST_Node*] the placeholder expressions",strings:"[string*] the raw text segments",tag:"[AST_Node?] tag function, or null if absent"},_equals:function(e){return prop_equals(this.tag,e.tag)&&list_equals(this.strings,e.strings)&&all_equals(this.expressions,e.expressions)},walk:function(t){var e=this;t.visit(e,function(){e.tag&&e.tag.walk(t),e.expressions.forEach(function(e){e.walk(t)})})},_validate:function(){if(this.expressions.length+1!=this.strings.length)throw new Error("malformed template with "+this.expressions.length+" placeholder(s) but "+this.strings.length+" text segment(s)");must_be_expressions(this,"expressions"),this.strings.forEach(function(e){if("string"!=typeof e)throw new Error("strings must contain string")}),null!=this.tag&&must_be_expression(this,"tag")}}),AST_Constant=DEFNODE("Constant",null,{$documentation:"Base class for all constants",_equals:function(e){return this.value===e.value},_validate:function(){if("Constant"==this.TYPE)throw new Error("should not instantiate AST_Constant")}}),AST_String=DEFNODE("String","quote value",{$documentation:"A string literal",$propdoc:{quote:"[string?] the original quote character",value:"[string] the contents of this string"},_validate:function(){if(null!=this.quote){if("string"!=typeof this.quote)throw new Error("quote must be string");if(!/^["']$/.test(this.quote))throw new Error("invalid quote: "+this.quote)}if("string"!=typeof this.value)throw new Error("value must be string")}},AST_Constant),AST_Number=DEFNODE("Number","value",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value"},_validate:function(){if("number"!=typeof this.value)throw new Error("value must be number");if(!isFinite(this.value))throw new Error("value must be finite");if(this.value<0)throw new Error("value cannot be negative")}},AST_Constant),AST_BigInt=DEFNODE("BigInt","value",{$documentation:"A BigInt literal",$propdoc:{value:"[string] the numeric representation"},_validate:function(){if("string"!=typeof this.value)throw new Error("value must be string");if("-"==this.value[0])throw new Error("value cannot be negative")}},AST_Constant),AST_RegExp=DEFNODE("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"},_equals:function(e){return""+this.value==""+e.value},_validate:function(){if(!(this.value instanceof RegExp))throw new Error("value must be RegExp")}},AST_Constant),AST_Atom=DEFNODE("Atom",null,{$documentation:"Base class for atoms",_equals:return_true,_validate:function(){if("Atom"==this.TYPE)throw new Error("should not instantiate AST_Atom")}},AST_Constant),AST_Null=DEFNODE("Null",null,{$documentation:"The `null` atom",value:null},AST_Atom),AST_NaN=DEFNODE("NaN",null,{$documentation:"The impossible value",value:NaN},AST_Atom),AST_Undefined=DEFNODE("Undefined",null,{$documentation:"The `undefined` value",value:void 0},AST_Atom),AST_Hole=DEFNODE("Hole",null,{$documentation:"A hole in an array",value:void 0},AST_Atom),AST_Infinity=DEFNODE("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},AST_Atom),AST_Boolean=DEFNODE("Boolean",null,{$documentation:"Base class for booleans",_validate:function(){if("Boolean"==this.TYPE)throw new Error("should not instantiate AST_Boolean")}},AST_Atom),AST_False=DEFNODE("False",null,{$documentation:"The `false` atom",value:!1},AST_Boolean),AST_True=DEFNODE("True",null,{$documentation:"The `true` atom",value:!0},AST_Boolean);function TreeWalker(e){this.callback=e,this.directives=Object.create(null),this.stack=[]}TreeWalker.prototype={visit:function(e,t){this.push(e),!this.callback(e,t||noop)&&t&&t(),this.pop()},parent:function(e){return this.stack[this.stack.length-2-(e||0)]},push:function(e){var t;e instanceof AST_Class?(this.directives=Object.create(this.directives),t="use strict"):e instanceof AST_Directive?t=e.value:e instanceof AST_Lambda&&(this.directives=Object.create(this.directives)),t&&!this.directives[t]&&(this.directives[t]=e),this.stack.push(e)},pop:function(){var e=this.stack.pop();(e instanceof AST_Class||e instanceof AST_Lambda)&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(e){for(var t=this.stack,n=t.length-1;0<=--n;){var o=t[n];if(o instanceof e)return o}},has_directive:function(e){var t=this.directives[e];if(t)return t;var n=this.stack[this.stack.length-1];if(n instanceof AST_Scope)for(var o=0;o<n.body.length;++o){var i=n.body[o];if(!(i instanceof AST_Directive))break;if(i.value==e)return i}},loopcontrol_target:function(e){var t,n=this.stack;if(e.label){for(var o=n.length;0<=--o;)if((t=n[o])instanceof AST_LabeledStatement&&t.label.name==e.label.name)return t.body}else for(o=n.length;0<=--o;)if((t=n[o])instanceof AST_IterationStatement||e instanceof AST_Break&&t instanceof AST_Switch)return t},in_boolean_context:function(){for(var e,t=!0,n=0,o=this.self();e=this.parent(n++);o=e){if(e instanceof AST_Binary)switch(e.operator){case"&&":case"||":e.left===o&&(t=!1);continue;default:return!1}if(!(e instanceof AST_Conditional)){if(e instanceof AST_DWLoop)return e.condition===o;if(e instanceof AST_For)return e.condition===o;if(e instanceof AST_If)return e.condition===o;if(e instanceof AST_Return){if(e.in_bool)return!0;for(;e=this.parent(n++);)if(e instanceof AST_Lambda){if(e.name)return!1;if("Call"!=(e=this.parent(n++)).TYPE)return!1;break}}if(e instanceof AST_Sequence){if(e.tail_node()===o)continue;return!t||"d"}return e instanceof AST_SimpleStatement?!t||"d":e instanceof AST_UnaryPrefix&&"!"==e.operator}if(e.condition===o)return!0}}};