<style>body{margin: 0;}</style>
<script src="./js/w.js"></script>
<script src="https://img1.ccgxk.com/jscdn/cannon.min.js"></script>
<img src='./img/texture.jpeg' id=marble hidden>
<canvas id=c width=320 height=300></canvas>
<div id="testinfo"></div>
<script>

// 一些数学函数
wMath = {
    quaternionToEuler: function(q){  // 四元数转化为欧拉数
        const { x, y,  z,  w } = q;
        const roll = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y)); // Roll (X轴)
        const sinPitch = 2 * (w * y - z * x);
        const pitch = Math.asin(Math.max(-1, Math.min(1, sinPitch))); // Pitch (Y轴)
        const yaw = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z)); // Yaw (Z轴)
        const toDeg = angle => angle * (180 / Math.PI); // 转为度数
        return { x: toDeg(roll), y: toDeg(pitch), z: toDeg(yaw)};
    },

    eulerToQuaternion: function(roll, pitch, yaw){  // 欧拉数转化为四元数
        const rollRad = roll * (Math.PI / 180);
        const pitchRad = pitch * (Math.PI / 180);
        const yawRad = yaw * (Math.PI / 180);
        const cr = Math.cos(rollRad * 0.5);
        const sr = Math.sin(rollRad * 0.5);
        const cp = Math.cos(pitchRad * 0.5);
        const sp = Math.sin(pitchRad * 0.5);
    },
}

// w.js 初始化
c.width = window.innerWidth - 100
c.height = window.innerHeight - 100
W.reset(c);
W.ambient(0.7);
W.light({ x: .5, y: -.3, z: -.5});
W.clearColor("8Af");

// 绘制原点坐标轴
W.group({n:'posZero',x:0,y:1,z:0});
W.cube({g:'posZero',x:5,w:10,h:.5,d:.5,b:"f44"});
W.cube({g:'posZero',y:5,h:10,w:.5,d:.5,b:"4f4"});
W.cube({g:'posZero',z:5,d:10,w:.5,h:.5,b:"44f"});
W.pyramid({g:'posZero',size:1,x:10,rz:-90,b:"f44"});
W.pyramid({g:'posZero',size:1,y:10,b:"4f4"});
W.pyramid({g:'posZero',size:1,z:10,rx:90,b:"44f"});

var ccgxk = {
    // ccgxk 的 cannon.js 物理世界
    world : null,

    // 默认材质关联材质
    cannonDefaultCantactMaterial : new CANNON.ContactMaterial( // 默认材质关联材质
        new CANNON.Material(),
        new CANNON.Material(), {
            friction: 0.1, // 摩擦力
            restitution: 0.1, // 弹性系数
    }),

    // 初始化物理世界
    initWorld : function(){
        this.world = new CANNON.World();
        this.world.gravity.set(0, -9.82, 0); // 地球重力9.82m/s²
        this.world.broadphase = new CANNON.NaiveBroadphase(); // 碰撞检测
        this.world.solver.iterations = 10; // 物理迭代
        this.world.addContactMaterial(this.cannonDefaultCantactMaterial);
    },

    // 物理体列表
    bodylist : new Array(),

    // 添加物理体
    addPhysicalBox : function({ 
                name = 'k'+(Math.random()*10**9|0),  // 如果没指认，则使用随机数生成 ID
                X = 5, Y = 5, Z = 5,
                mass = 5, width = 1, depth = 1, height = 1,
                texture = null, smooth = 0.8, background = '#888', mixValue = 0.71, rX = 0, rY = 0, rZ = 0 } = {}){
        const body = new CANNON.Body({
            mass,
            shape: new CANNON.Box(new CANNON.Vec3(width, height, depth)),
            position: new CANNON.Vec3(X, Y, Z),
            material: ccgxk.cannonDefaultCantactMaterial,
        });
        this.world.addBody(body);
        W.cube({
            n: name,
            w: width * 2, d: depth * 2, h: height * 2,
            x: X, y:Y, z:Z, t: texture, s: smooth,
            rx: rX, ry: rY, rz: rZ, b: background, mix: mixValue
        });
        var result = { name, body, rX, rY, rZ };
        this.bodylist.push(result);
        return result;
    },

    // 按照列表将 物理体 逐个更新
    updataBodylist : function(){
        for (let i = 0; i < this.bodylist.length; i++) {
            let indexItem = this.bodylist[i];
            let pos = indexItem.body.position;
            W.move({
                n: this.bodylist[i].name,
                x: pos.x,
                y: pos.y,
                z: pos.z,
                rx: indexItem.rX,
                ry: indexItem.rY,
                rz: indexItem.rZ,
            });
        }
    },

    // 操作状态值
    keys : {
        viewForward: 0,
        viewBackward: 0,
        turnRight: 0,
        turnLeft: 0,
        turnUp: 0,
        turnDown: 0,
        viewUp: 0,
        viewDown: 0,
        viewLeft: 0,
        viewRight: 0,
        shiftKeyvalue: 0,
        jumping: 0,
    },

    // 键盘按键与操作状态值的对应
    keyMap : { // 键盘按键与操作值的对应关系
        'w': 'viewForward',
        's': 'viewBackward',
        'a': 'viewLeft',
        'd': 'viewRight',
        'r': 'viewUp',
        'v': 'viewDown',
        'o': 'turnUp',
        'p': 'turnDown',
        'k': 'viewLeft',
        'l': 'viewRight',
        'arrowup': 'viewForward',
        'arrowdown': 'viewBackward',
        'arrowleft': 'turnLeft',
        'arrowright': 'turnRight',
    },

    // 事件监听
    eventListener : function(){
        var _this = this;
        var isMouseMove = false;
        document.addEventListener('keydown', function(e) {  // 按下键盘
            _this._handleKey(e, 1);
        });
        document.addEventListener('keyup', function(e) {  // 松开键盘
            _this._handleKey(e, 0);
        });
        document.addEventListener('mousemove', function(e) {  // 鼠标移动
            if (isMouseMove) {
                _this.keys.turnRight = e.movementX * 0.1;
                _this.keys.turnUp = e.movementY * 0.1;
            }
        });
        c.addEventListener('click', () => {  // 点击画布，开启虚拟鼠标
            c.requestPointerLock = c.requestPointerLock || c.mozRequestPointerLock || c.webkitRequestPointerLock;
            c.requestPointerLock();
            isMouseMove = true;
        });
        document.addEventListener('pointerlockchange', lockChangeAlert, false);
        document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
        document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);
        function lockChangeAlert() {  // 单击 ESC 键后
            if (document.pointerLockElement === c || document.mozPointerLockElement === c || document.webkitPointerLockElement === c) {
                isMouseMove = true;
            } else {
                isMouseMove = false;
            }
        }
    },

    // 键盘事件处理逻辑
    _handleKey : function(e, value) {
        if (this.keyMap[e.key.toLowerCase()]) {
            this.keys[this.keyMap[e.key.toLowerCase()]] = value;
        }
        if (e.keyCode === 32 && this.mainVPlayer !== null) {  // 空格键
            var limit = this.mainVPlayer.body.position.y <= 0;
            limit = true;
            if (this.keys.jumping === 0 && limit) {
                this.mainVPlayer.body.velocity.y = 10;
            }
            this.keys.jumping = value;
        }
    },

    // 计算视角移动参数
    calMovePara : function(X, Y, Z, RX, RY, RZ){
        const keys = this.keys;
        if (keys.viewForward || keys.viewBackward) { // 前后平移
            Z += (-keys.viewForward + keys.viewBackward) * Math.cos(RY * Math.PI / 180) / 4;
            X += (-keys.viewForward + keys.viewBackward) * Math.sin(RY * Math.PI / 180) / 4;
        }
        if (keys.viewLeft || keys.viewRight) { // 左右平移
            Z += (-keys.viewLeft + keys.viewRight) * Math.cos((RY + 90) * Math.PI / 180) / 10;
            X += (-keys.viewLeft + keys.viewRight) * Math.sin((RY + 90) * Math.PI / 180) / 10;
        }
        if (keys.viewUp || keys.viewDown) { // 上下平移
            var offset = (keys.viewUp - keys.viewDown) / 7;
            Y += offset;
        }
        if(keys.turnRight || keys.turnLeft) {  // 左右扭动
            var offset = (-keys.turnRight + keys.turnLeft);
            if(Math.abs(offset) > 0.1){
                RY += offset;
            }
        }
        if(keys.turnUp || keys.turnDown) {  // 上下扭动
            var offset = (-keys.turnUp + keys.turnDown);
            if(Math.abs(offset) > 0.5){
                // if ((offset > 0 && RX < 0) || (offset < 0 && RX > -180)) {  // 限制（测试中）
                RX += offset;
                // }
            }
        }
        return {  x: X,  y: Y,  z: Z,  rx: RX,  ry: RY,  rz: RZ  }
    },

    // 主角物理体
    mainVPlayer : null,

    // 主角物理体的移动
    mainVPlayerMove : function(cannonObj){
        if(cannonObj === null){return};
        const { position, quaternion } = cannonObj.body;
        const { x, y, z, rx, ry, rz } = this.calMovePara(
            position.x, position.y, position.z,
            cannonObj.rX, cannonObj.rY, cannonObj.rZ
        );
        Object.assign(position, {  x,  y,  z  });
        
        cannonObj.rY = ry;
        /* ------------[ 还未成熟的旋转，这是实验区 ]----------------- */
        cannonObj.rZ = rz;
        cannonObj.rX = rx;
        // W.camera({ rx: rx, ry: ry, rz: rz });
        /* ----------------------------- */
        return 0;
    },

    // 物理世界运动的参数
    cannonAni : function(){
        const timeStep = 1 / 60; // 时间步长
        this.world.step(timeStep); // 更新物理世界
    },

    animate : function(){
        _this = this;
        const viewAnimate = function() {
            requestAnimationFrame(viewAnimate);
            _this.cannonAni(); // 物理世界
            _this.updataBodylist(); // 更新物体列表
            _this.mainVPlayerMove(_this.mainVPlayer); // 主角移动
        }
        
        viewAnimate();
    },




}
ccgxk.initWorld();

ccgxk.addPhysicalBox({  // 创建一个 测试 物理体
    name: 'test', X: -30, Y: 1, Z: -30,
    mass: 5, width: 10, depth: 15, height: 1, texture: marble
});

ccgxk.addPhysicalBox({  // 创建地面
    name: 'groundPlane', X: 0, Y: 0, Z: 0,
    mass: 0, width: 100, depth: 100, height: 0.01,
    texture: marble, background: '#FFF', mixValue: 0.71, rX: 0
});

// 小球的初始旋转
var ballRX = 0;   var ballRY = 0;   var ballRZ = 0;

ccgxk.mainVPlayer = ccgxk.addPhysicalBox({  // 创建一个立方体，并设置为主角
    name: 'mainPlayer', X: 15, Y: 20, Z: 30,
    rX: 0, rY: 0, rZ: 0,
    mass: 5, texture: marble
})

ccgxk.eventListener(); // 事件监听
ccgxk.animate(); // 动画

W.camera({g: 'mainPlayer', z:7, y: 2.6})// 摄像机

/* ---------------------------------------------------------------------------------------- */

// 原主角
// const oldmainVPlayer = new CANNON.Body({
//     mass: 5,
//     shape: new CANNON.Box(new CANNON.Vec3(1, 1, 1)), // 立方体，边长为 1
//     position: new CANNON.Vec3(30, 30, 30), // 位置
//     material: ccgxk.cannonDefaultCantactMaterial,
// });
// ccgxk.world.addBody(oldmainVPlayer);
// W.group({ n: "ball", x:30, y:1, z:30,rx:ballRX,ry:ballRY,rz:ballRZ});
// W.cube({g:"ball",n:"ball_sphere",size:2, t:marble,s:0.8,rx:0,ry:0,rz:0});


</script>