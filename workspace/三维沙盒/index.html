<style>body{margin: 0;}</style>
<script src="./js/w.js"></script>
<script src="https://img1.ccgxk.com/jscdn/cannon.min.js"></script>
<img src='./img/texture.jpeg' id=marble hidden>
<canvas id=c width=320 height=300></canvas>
<div id="testinfo"></div>
<script>

// 变量区
var X = 7.2, Z = 30.8, Y = 14.3, RX = -104.2, RY = -15.7, RZ = 0;  // 这些是主角的初始位置

// 小球的初始旋转
var ballRX = 0;   var ballRY = 0;   var ballRZ = 0;

// 函数区
wMath = {
    quaternionToEuler: function(q){  // 四元数转化为欧拉数
        const { x, y,  z,  w } = q;
        const roll = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y)); // Roll (X轴)
        const sinPitch = 2 * (w * y - z * x);
        const pitch = Math.asin(Math.max(-1, Math.min(1, sinPitch))); // Pitch (Y轴)
        const yaw = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z)); // Yaw (Z轴)
        const toDeg = angle => angle * (180 / Math.PI); // 转为度数
        return { x: toDeg(roll), y: toDeg(pitch), z: toDeg(yaw)};
    },

    eulerToQuaternion: function(roll, pitch, yaw){  // 欧拉数转化为四元数
        const rollRad = roll * (Math.PI / 180);
        const pitchRad = pitch * (Math.PI / 180);
        const yawRad = yaw * (Math.PI / 180);
        const cr = Math.cos(rollRad * 0.5);
        const sr = Math.sin(rollRad * 0.5);
        const cp = Math.cos(pitchRad * 0.5);
        const sp = Math.sin(pitchRad * 0.5);
    },
}

// w.js 初始化
c.width = window.innerWidth - 100
c.height = window.innerHeight - 100
W.reset(c);
W.ambient(0.7);
W.light({ x: .5, y: -.3, z: -.5});
W.clearColor("8Af");

// 绘制原点坐标轴
W.group({n:'posZero',x:0,y:1,z:0});
W.cube({g:'posZero',x:5,w:10,h:.5,d:.5,b:"f44"});
W.cube({g:'posZero',y:5,h:10,w:.5,d:.5,b:"4f4"});
W.cube({g:'posZero',z:5,d:10,w:.5,h:.5,b:"44f"});
W.pyramid({g:'posZero',size:1,x:10,rz:-90,b:"f44"});
W.pyramid({g:'posZero',size:1,y:10,b:"4f4"});
W.pyramid({g:'posZero',size:1,z:10,rx:90,b:"44f"});

// 物理引擎初始化
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0); // 地球重力9.82m/s²
world.broadphase = new CANNON.NaiveBroadphase(); // 碰撞检测
world.solver.iterations = 10; // 物理迭代
const cannonDefaultCantactMaterial = new CANNON.ContactMaterial( // 默认材质关联材质
    new CANNON.Material(),
    new CANNON.Material(), {
        friction: 0.1, // 摩擦力
        restitution: 0.1, // 弹性系数
    }
)
world.addContactMaterial(cannonDefaultCantactMaterial);

var ccgxk = {
    ccgxkWorld : null,

    initCcgxkWorld : function(){
        const ccgxkWorld = new CANNON.World();
        ccgxkWorld.gravity.set(0, -9.82, 0); // 地球重力9.82m/s²
        ccgxkWorld.broadphase = new CANNON.NaiveBroadphase(); // 碰撞检测
        ccgxkWorld.solver.iterations = 10; // 物理迭代
        ccgxkWorld.addContactMaterial(cannonDefaultCantactMaterial);
    },

    // 物理体列表
    bodylist : new Array(),

    // 添加物理体
    addPhysicalBox : function({ 
                name = 'k'+(Math.random()*10**9|0),  // 如果没指认，则使用随机数生成 ID
                X = 5, Y = 5, Z = 5,
                mass = 5, width = 1, depth = 1, height = 1,
                texture = null, smooth = 0.8, background = '#888', mixValue = 0.71, rX = 0, rY = 0, rZ = 0
            } = {}){
        const body = new CANNON.Body({
            mass,
            shape: new CANNON.Box(new CANNON.Vec3(width, height, depth)),
            position: new CANNON.Vec3(X, Y, Z),
            material: cannonDefaultCantactMaterial,
        });
        world.addBody(body);
        W.cube({
            n: name,
            w: width * 2, d: depth * 2, h: height * 2,
            x: X, y:Y, z:Z, t: texture, s: smooth,
            rx: rX, ry: rY, rz: rZ, b: background, mix: mixValue
        });
        this.bodylist.push({ name, body });
        return body;
    },

    // 按照列表将 物理体 逐个更新
    updataBodylist : function(){
        for (let i = 0; i < this.bodylist.length; i++) {
            let pos = this.bodylist[i].body.position;
            W.move({
                n: this.bodylist[i].name,
                x: pos.x,
                y: pos.y,
                z: pos.z,
            });
        }
    }
}
ccgxk.addPhysicalBox({name: 'test', X: -30, Y: 1, Z: -30, mass: 0, width: 10, depth: 15, height: 1, texture: marble}); 

// 创建地面物理体
const groundBody = new CANNON.Body({ // 添加地面
    mass: 0, // 质量为 0
    position: new CANNON.Vec3(0, 0, 0), // 坐标原点
    shape: new CANNON.Plane(), // 一个无限延伸的平面
    material: cannonDefaultCantactMaterial,
});
groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // 旋转平面90度
world.addBody(groundBody);

// w.js 创建地面模型
W.cube({n:'ground',x:0,y:0,z:0,w:100*100,d:100*100,h:0.01,t:marble,b:'#FFF',mix:0.71});

// 创建主角物理体
const sphereBody = new CANNON.Body({
    mass: 500,
    shape: new CANNON.Box(new CANNON.Vec3(1, 1, 1)), // 立方体，边长为 1
    position: new CANNON.Vec3(30, 30, 30), // 位置
    material: cannonDefaultCantactMaterial,
});
world.addBody(sphereBody);

// w.js 创建主角球体模型
W.group({ n: "ball", x:30, y:30, z:30,rx:ballRX,ry:ballRY,rz:ballRZ});
W.cube({g:"ball",n:"ball_sphere",size:2, t:marble,s:0.8,rx:0,ry:0,rz:0});

/* -----------------------------------[ 实验区 ]------------------------------------------ */
// function addPhysicalBox({ name = 'k'+(Math.random()*10**9|0), x = 5, y = 5, z = 5, mass = 5, width = 1, depth = 1, height = 1 } = {}) {
//     const body = new CANNON.Body({
//         mass,
//         shape: new CANNON.Box(new CANNON.Vec3(width, height, depth)),
//         position: new CANNON.Vec3(x, y, z),
//         material: cannonDefaultCantactMaterial,
//     });
//     world.addBody(body);
//     W.cube({ n: name, w: width * 2, d: depth * 2, h: height * 2, x, y, z, t: marble, s: 0.8, rx: 0, ry: 0, rz: 0 });
//     bodylist.push({ name, body });
//     return body;
// }
// function updataBodylist(){
//     for (let i = 0; i < bodylist.length; i++) {
//         let pos = bodylist[i].body.position;
//         W.move({
//             n: bodylist[i].name,
//             x: pos.x,
//             y: pos.y,
//             z: pos.z,
//         });
//     }
// }








/* ----------------------------------------------------------------------------- ****************************************************/

W.camera({g: "ball", z: 15, y: 5, rx: 0}); // 摄像机，此时它的 g 属性为主角 sphere 的 n 属性，摄像机与主角绑定

// 按键事件
keys = { // 操作值
    viewForward: 0,
    viewBackward: 0,
    turnRight: 0,
    turnLeft: 0,
    turnUp: 0, // 视角向上转动
    turnDown: 0,
    viewUp: 0,
    viewDown: 0,
    viewLeft: 0,
    viewRight: 0,
    shiftKeyvalue: 0,
    jumping: 0,
};
const keyMap = { // 键盘按键与操作值的对应关系
    'w': 'viewForward',
    's': 'viewBackward',
    'a': 'viewLeft',
    'd': 'viewRight',
    'r': 'viewUp',
    'v': 'viewDown',
    'o': 'turnUp',
    'p': 'turnDown',
    'k': 'viewLeft',
    'l': 'viewRight',
    'arrowup': 'viewForward',
    'arrowdown': 'viewBackward',
    'arrowleft': 'turnLeft',
    'arrowright': 'turnRight',
};
const handleKey = (e, value) => {
    if (keyMap[e.key.toLowerCase()]) {
        keys[keyMap[e.key.toLowerCase()]] = value;
    }
    if (e.keyCode === 32) {
        // 空格键
        if (keys.jumping === 0  && sphereBody.position.y <= 3) {
            sphereBody.velocity.y = 10; // 跳跃
        }
        keys.jumping = value;
    }
};
onkeydown = e => handleKey(e, 1);
onkeyup = e => handleKey(e, 0);

// 小球移动变化
function ballMoveAction() {
    const {
        position,
        quaternion
    } = sphereBody;
    const { x, y, z, rx, ry, rz } = calMovePara(
        position.x, position.y, position.z,
        ballRX, ballRY, ballRZ
    );
    Object.assign(position, {  x,  y,  z  });
    ballRX = rx;
    ballRY = ry;
    ballRZ = rz;
    return 0;
}

// 函数，计算移动和旋转的变化
function calMovePara(X, Y, Z, RX, RY, RZ) {
    if (keys.viewForward || keys.viewBackward) { // 前后平移
        Z += (-keys.viewForward + keys.viewBackward) * Math.cos(RY * Math.PI / 180) / 4;
        X += (-keys.viewForward + keys.viewBackward) * Math.sin(RY * Math.PI / 180) / 4;
    }
    if (keys.viewLeft || keys.viewRight) { // 左右平移
        Z += (-keys.viewLeft + keys.viewRight) * Math.cos((RY + 90) * Math.PI / 180) / 10;
        X += (-keys.viewLeft + keys.viewRight) * Math.sin((RY + 90) * Math.PI / 180) / 10;
    }
    if (keys.viewUp || keys.viewDown) { // 上下平移
        var offset = (keys.viewUp - keys.viewDown) / 7;
        Y += offset;
    }
    if(keys.turnRight || keys.turnLeft) {  // 左右扭动
      var offset = (-keys.turnRight + keys.turnLeft);
      if(Math.abs(offset) > 0.1){
          RY += offset;
      }
    }
    if(keys.turnUp || keys.turnDown) {  // 上下扭动
      var offset = (-keys.turnUp + keys.turnDown);
      if(Math.abs(offset) > 0.5){
        // if ((offset > 0 && RX < 0) || (offset < 0 && RX > -180)) {  // 限制
          RX += offset;
        // }
      }
    }
    return {  x: X,  y: Y,  z: Z,  rx: RX,  ry: RY,  rz: RZ  }
}

// Pointer Lock 和鼠标移动事件
let isMouseMove = false;
c.addEventListener('mousemove', (e) => {
    if (isMouseMove) {
        keys.turnRight = e.movementX * 0.1;
        keys.turnUp = e.movementY * 0.1;
    }
});
c.addEventListener('click', () => {
    c.requestPointerLock = c.requestPointerLock || c.mozRequestPointerLock || c.webkitRequestPointerLock;
    c.requestPointerLock();
    isMouseMove = true;
});
document.addEventListener('pointerlockchange', lockChangeAlert, false);
document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);
function lockChangeAlert() {
    if (document.pointerLockElement === c || document.mozPointerLockElement === c || document.webkitPointerLockElement === c) {
        isMouseMove = true;
    } else {
        isMouseMove = false;
    }
}

// 物理动作
function cannonAni() {
    const timeStep = 1 / 60; // 时间步长
    world.step(timeStep); // 更新物理世界
    W.move({ // 更新球体位置和旋转
        n: "ball",
        x: sphereBody.position.x,
        y: sphereBody.position.y,
        z: sphereBody.position.z,
        rx: ballRX,
        ry: ballRY,
        rz: ballRZ
    });
    W.move({n:"ball_sphere", g: null,
        x: sphereBody.position.x,
        y: sphereBody.position.y,
        z: sphereBody.position.z,
        rx:0,ry:ballRY,rz:0
    });
}

// 帧运行
function animate() {
    requestAnimationFrame(animate);
    ballMoveAction(); // 小球的移动变化
    cannonAni(); // 物理世界
    ccgxk.updataBodylist(); // 更新物体列表
}
animate();

</script>